#!/usr/bin/env python3

# ZATHURA_COLORABLES = ('completion-bg',
#                       'completion-fg',
#                       'completion-group-bg',
#                       'completion-group-fg',
#                       'completion-highlight-bg',
#                       'completion-highlight-fg',
#                       'default-fg',
#                       'default-bg',
#                       'inputbar-bg',
#                       'inputbar-fg',
#                       'notification-bg',
#                       'notification-fg',
#                       'notification-error-bg',
#                       'notification-error-fg',
#                       'notification-warning-bg',
#                       'notification-warning-fg',
#                       'statusbar-bg',
#                       'statusbar-fg',
#                       'highlight-color',
#                       'highlight-fg',
#                       'highlight-active-color',
#                       'recolor-darkcolor',
#                       'recolor-lightcolor',
#                       'render-loading-bg',
#                       'render-loading-fg',
#                       'index-fg',
#                       'index-bg',
#                       'index-active-fg',
#                       'index-active-bg')


from dataclasses import dataclass
from typing import List, Final
from datetime import datetime
from argparse import ArgumentParser, Namespace
from sys import stderr
import logging
import json
import os
import shutil
import re


@dataclass
class Color:
    red: int
    green: int
    blue: int
    alpha: float = 1

    def __str__(self):
        """
        If α = 1, we color is fully opaque and therefore stringafy as "#RRGGBB".
        If α ≠ 1, we color is translucent/transparent and we stringafy
            as rgba(R,G,B,α).
        """
        if self.alpha >= 0 and self.alpha < 1:
            # INFO: Zathura does not allow spaces after commas in rgba(r,g,b,α).
            return f'rgba({self.red:d},{self.green:d},{self.blue:d},{self.alpha:.2f})'
        elif self.alpha == 1:
            # BUG: Enforces "#RRGGBB" over \#RRGGBB, regardless of user's style.
            # TODO: Preserve user's style. Perhaps use the first occurance of a
            #   hex color spec to set the preference.
            return f'"#{self.red:02X}{self.green:02X}{self.blue:02X}"'
        else:
            raise ValueError('Alpha channel is out of bounds: ' +
                             str(self.alpha) + ' ∉ [0, 1]: float.' +
                             ' Value was changed after Color initialisation.')

    def __post_init__(self):
        def invalid_8bit(x: int) -> bool:
            return x < 0 or x > 255
        if invalid_8bit(self.red):
            raise ValueError('Red channel is out of bounds: ' +
                             str(self.red) + ' ∉ [0, 255]: int.')
        if invalid_8bit(self.green):
            raise ValueError('Green channel is out of bounds: ' +
                             str(self.green) + ' ∉ [0, 255]: int.')
        if invalid_8bit(self.blue):
            raise ValueError('Blue channel is out of bounds: ' +
                             str(self.blue) + ' ∉ [0, 255]: int.')
        if self.alpha < 0 or self.alpha > 1:
            raise ValueError('Alpha channel is out of bounds: ' +
                             str(self.alpha) + ' ∉ [0, 1]: float.')


SUPPORTED_COLORABLES = ['default-bg']


@dataclass(kw_only=True)
class ZathuraSetColorCmd:
    prop: str
    val: Color
    rem: str

    def __str__(self):
        strval = 'set ' + self.prop + ' ' + str(self.val)
        if self.rem:
            strval += '  # ' + self.rem
        return strval

    def __post_init__(self):
        if self.prop not in SUPPORTED_COLORABLES:
            raise ValueError('Property \'' + self.prop +
                             '\' is not a supported colourable')


ZathuraLine = str | ZathuraSetColorCmd


def with_alpha(c: Color, alpha: float) -> Color:
    return Color(red=c.red, green=c.green, blue=c.blue, alpha=alpha)


HEX_COLOR_PATTERN: Final[re.Pattern[str]] = re.compile(
    r'[\"\\](?:(?!(?:\;|\n|\r))[\w\W])*?' +
    r'#(?:([a-fA-F0-9]{1,2})([a-fA-F0-9]{1,2})([a-fA-F0-9]{1,2}))' +
    r'(?:(?!(?:\;|\n|\r))[\w\W])*?(?:\"|\n|\r|#)')
RGBA_COLOR_PATTERN: Final[re.Pattern[str]] = re.compile(
    r'rgba\((\d+),\s*(\d+),\s*(\d+),\s*(\d*.?\d+)\)')


def str_to_color(s: str) -> Color:
    """
    Tries to parse a hex #RRGGBB color, or rgba(R,G,B,α)
        from anywhere in argument s.
    """
    if hex_matches := HEX_COLOR_PATTERN.findall(s):
        [(r, g, b)] = hex_matches
        return Color(red=int(r, 16),
                     green=int(g, 16),
                     blue=int(b, 16))
    elif rgba_matches := RGBA_COLOR_PATTERN.findall(s):
        [(r, g, b, a)] = rgba_matches
        return Color(red=int(r),
                     green=int(g),
                     blue=int(b),
                     alpha=float(a))
    else:
        raise ValueError('Unable to parse color from string: ' + s)


def backup_file(path: str) -> None:
    tgt_path = path + datetime.now().strftime("_%Y-%b-%d-%H:%M:%S")
    logging.info('Backing up: \n\t' + path + ' ↦ ' + tgt_path)
    shutil.copyfile(path, tgt_path)


ZATHURA_SET_CMD_PATTERN: Final[re.Pattern[str]] = re.compile(
    r'set\s+(\S+)\s+(\S+)')
TRAILING_COMMENT_PATTERN: Final[re.Pattern[str]] = re.compile(
    r'^set\s+\S+\s+\S+[\"\) \t]\s*#\s*(.*)$')


def parse_zrc_line(rawline: str) -> ZathuraLine:
    '''
    If the argument string can be parsed into:
        set COLORABLE COLOR # REMARK
    into a ZathuraSetColorCmd. If it can't, then it just right-strips
    the argument and returns that string.

    INFO: Zathura allows trailing comments without space:
        set … "#RRGGBB"#foobar ← this is valid.  (A)
        set … \\#RRGGBB#foobar  ← so is this.    (B)
    BUG: (1) Current regex matching requires one of ", ) or ␠ before the
      comment.
    BUG: (2) Current parsing does not preserve white space, so the user's
      indent pattern will be broken by any line changed in SUPPORTED_COLORABLES.
    TODO: Implement a full parser that also preserves the white space in the
      user's zathurarc to address BUGS (1) and (2).
    PERF: This function is needlessly inefficient.
    TODO: Unify return. Needlessly large function exit surface.
    '''

    if rawline == '\n' or rawline.strip()[0] == '#':
        return rawline.rstrip()

    if any(prop in rawline for prop in SUPPORTED_COLORABLES):
        if trailing_comment_match := TRAILING_COMMENT_PATTERN.findall(rawline):
            [(remark)] = trailing_comment_match
        else:
            remark = ''
        matches = ZATHURA_SET_CMD_PATTERN.match(rawline)
        if not matches:
            raise ValueError('This line is ill-formed and could not be parsed:' +
                             '\n\t' + rawline)

        if matches.group(1) not in SUPPORTED_COLORABLES:
            raise ValueError(
                'A parsable command was detected here but parsing failed:' +
                '\n\t' + rawline +
                '\nOne of the following properties was detected:' +
                str(SUPPORTED_COLORABLES) +
                '\nbut parser matched:' + matches.group(1))

        return ZathuraSetColorCmd(prop=matches.group(1),
                                  val=str_to_color(
                                      matches.group(2).strip()),
                                  rem=remark)
    else:
        return rawline.rstrip()


def make_set_color(prop: str,
                   pywal_colors) -> ZathuraSetColorCmd:
    logging.debug('make_set_color, property=\'' + prop + '\'')
    rem = "From zathura-pywalbg"

    if prop == 'default-bg':
        bg_color: Color = str_to_color(
            '\"' + pywal_colors['special']['background']+'\"')
        return ZathuraSetColorCmd(prop=prop,
                                  val=with_alpha(
                                      bg_color, alpha=pywal_colors['alpha']),
                                  rem=rem)
    else:
        raise ValueError('Property \'' + prop +
                         '\' not in supported colourables:\n\t' +
                         str(SUPPORTED_COLORABLES))


def main(args: Namespace) -> None:
    """
    Opens and parses the pywal json file, then opens and parses zathurarc,
    and changes the SUPPORTED_COLORABLES with colours from pywal.

    BUG: (1) assumes default-bg is set in users zathurarc and replaces it,
        and the program is idempotent if they don't.
    TODO: (1) If default-bg is not in user's zathurarc, add it.

    TODO: I know there's other required settings to make bg transparency work.
        check for those.
    """

    zathura_cmds: List[ZathuraLine] = []
    found_colorables = {x: False for x in SUPPORTED_COLORABLES}

    with open(args.pywal_json_path, 'r') as wal_color_file:
        pywal_colors = json.load(wal_color_file)
        pywal_colors['alpha'] = args.alpha

    logging.debug('Finished parsing pywal colours with:' + str(pywal_colors))

    def is_set_default_bg(x: ZathuraLine) -> bool:
        return isinstance(x, ZathuraSetColorCmd) and x.prop == 'default-bg'

    with open(args.zathurarc_path, 'r') as zathurarc:
        for i, rawline in enumerate(zathurarc):
            lineno: int = i + 1
            try:
                line: ZathuraLine = parse_zrc_line(rawline)
                if is_set_default_bg(line):
                    found_colorables['default-bg'] = True
                    line = make_set_color('default-bg', pywal_colors)
                zathura_cmds.append(line)
            except ValueError as parse_err:
                raise ValueError(
                    'At ' + args.zathurarc_path + ':' + str(lineno)) from parse_err

    logging.debug('Finished parsing zathurarc with found:' + str(found_colorables))
    for prop, found in found_colorables.items():
        if found == False:
            logging.debug('Creating \'' + prop +
                          '\', since it was not found in user zathurarc.')
            zathura_cmds.append(make_set_color(prop, pywal_colors))

    if not args.no_backup and not args.dry_run:
        backup_file(args.zathurarc_path)
    if not args.dry_run:
        with open(args.zathurarc_path, 'w') as zathurarc:
            zathurarc.write('\n'.join(map(str, zathura_cmds)))
    else:
        print('\n'.join(map(str, zathura_cmds)))


if __name__ == "__main__":
    args = ArgumentParser(
        description="Sets `default-bg` in zathurarc based on pywal colours.")

    args.add_argument('--alpha',
                      default='0.8',
                      type=float,
                      help='Background transparency, Default: 0.8. (Should match kitty\'s config.')
    args.add_argument('--no-backup',
                      action='store_true',
                      dest='no_backup',
                      help='Do not back up existing zathurarc.')
    args.add_argument('--zathurarc-path',
                      type=str,
                      dest='zathurarc_path',
                      default=os.environ['HOME'] + '/.config/zathura/zathurarc',
                      help='Full path to zathurarc file. Default: ~/.config/zathura/zathurarc')
    args.add_argument('--pywal-json-path',
                      type=str,
                      dest='pywal_json_path',
                      default=os.environ['HOME'] + '/.cache/wal/colors.json',
                      help='Full path to zathurarc file. Default: ~/.cache/wal/colors.json')
    args.add_argument('--dry-run',
                      action='store_true',
                      dest='dry_run',
                      help='Print output to stdout instead of zathurarc.')

    args.add_argument("-log", "--log",
                      type=str,
                      default='WARNING',
                      help="Set logging level. DEBUG, INFO, WARNING, etc.'")

    clargs: Namespace = args.parse_args()

    logging.basicConfig(stream=stderr, encoding='utf-8', level=clargs.log)
    logging.debug('Parsed commandline arguments:' + str(clargs))

    main(clargs)
